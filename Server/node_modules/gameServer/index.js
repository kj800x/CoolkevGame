var fs = require('fs');
// file is included here:
eval(fs.readFileSync('../both.js') + '');

function run() {
  checkcollisions();
  for (var unitindex in unitarray) {
    unitarray[unitindex].calculatelivingness();
    unitarray[unitindex].tick();
    if (unitarray[unitindex].dead) {
      Arrayremove(unitarray, unitindex);
    }
  }
  sendToAllConnections(JSON.stringify(unitarray));
  checkVitals();
}

function checkVitals() {/*
  var i = 0;
  for (i = 0; i < clients.length; i++){
    console.log (clients[i].lastHeartbeat - new Date());
    if (new Date() - clients[i].lastHeartbeat > 2000){
      clients[i].disconnected();
      connections[clients[i].connectionindex].close();
      connections.splice(clients[i].connectionindex, 1);
      clients.splice(clients[i].listIndex, 1);
    }
  }*/
}
function checkcollisions() {
  var k, j;
  for (j = 0; j < unitarray.length - 1; j++) {
    for (k = j + 1; k < unitarray.length; k++) {
      var l = (Math.pow(unitarray[j].x - unitarray[k].x, 2) + Math.pow(unitarray[j].y - unitarray[k].y, 2));
      var r = Math.pow(unitarray[k].hitcircle() + unitarray[j].hitcircle(), 2);
      if (l <= r) {
        try {
          unitarray[j].hit(unitarray[k].type, unitarray[k].side);
        } catch (e) {}
        try {
          unitarray[k].hit(unitarray[j].type, unitarray[j].side);
        } catch (e) {}
      }
    }
  }
}

function generatebullet(side, x, y, velocity, TTL, variation) {
  if (variation === undefined) {
    variation = 0;
  }
  var returnvalue = new unit(side, x, y);
  returnvalue.type = "bullet";
  returnvalue.hit = function (type, side) {};
  returnvalue.velocity = new vector(velocity.direction + (2 * (Math.random() - .5) * variation), velocity.magnitude + 2 + (Math.random() * variation));
  returnvalue.TTL = TTL;
  returnvalue.tick = function () {
    this.x += Math.cos(this.velocity.radian()) * this.velocity.magnitude;
    this.y += Math.sin(this.velocity.radian()) * this.velocity.magnitude;
    this.TTL--;
  }
  returnvalue.calculatelivingness = function () {
    if (this.TTL <= 0) {
      this.dead = true;
      unitarray.push(generateexplosion(this.x, this.y, 20));
    }
  }
  returnvalue.render = function (cx, vpx, vpy) {
    cx.beginPath();
    cx.strokeStyle = this.side.color.toHEX();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.lineTo(this.x - vpx + (Math.cos(this.velocity.radian()) * 5), this.y - vpy + (Math.sin(this.velocity.radian()) * 5));
    cx.closePath();
    cx.stroke();
  }
  returnvalue.hitcircle = function () {
    return 2;
  }
  return returnvalue;
}

function generateexplosion(x, y, size) {
  var returnvalue = new unit(sides.ammo, x, y);
  returnvalue.size = size;
  returnvalue.indicatorstyle = "#FFFFFF"
  returnvalue.width = 1;
  returnvalue.type = "explosion";
  returnvalue.hit = function (type, side) {};
  returnvalue.calculatelivingness = function () {
    if (this.width > this.size) {
      this.dead = true;
    }
  }
  returnvalue.tick = function () {
    this.width++;
  }
  returnvalue.render = function (cx, vpx, vpy) {
    cx.strokeStyle = this.side.color.toHEX();
    cx.beginPath();
    //cx.moveTo(this.x-vpx,this.y-vpy);
    cx.arc(this.x - vpx, this.y - vpy, 1 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    cx.beginPath();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.arc(this.x - vpx, this.y - vpy, .5 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    cx.beginPath();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.arc(this.x - vpx, this.y - vpy, .25 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    this.width++;
  }
  returnvalue.hitcircle = function () {
    return this.width;
  }
  return returnvalue;
}

function generateammoside(sidename, sidecolor) {
  return {
    "name": sidename + "_Ammo",
    "color": new color(sidecolor.r * (20 / 51), sidecolor.g * (20 / 51), sidecolor.b * (20 / 51))
  }
}

function side(name, color) {
  this.color = color;
  this.name = name;
  this.ammoside = generateammoside(name, color);
}

function unit(side, x, y) {
  this.side = side;
  this.x = x;
  this.y = y;
  this.dead = false;
  this.velocity = new vector(0, 0);
  this.indicatorstyle = side.color.toHEX()
  this.tick = function () {};
}
/*

function generateplayer(side,x,y){
      	var returnvalue = new unit(side,x,y);
        returnvalue.calculatelivingness = function(){
          if (this.health <= 0){
            this.dead = true;
            unitarray.push(generateexplosion(this.x, this.y, 100));
            this.deconstruct();
          }
        }
        returnvalue.type = "player";
        returnvalue.indicatorstyle = side.color.toHEX()
        returnvalue.hit = function(type,side){
          if (type=="explosion"){this.health--}
          if (type=="bullet" && side != this.side){this.health--}
          if (type=="player"){this.health = 0;}
          if (type=="spawnpoint"){this.health++}
          if (type=="timebomb"){this.velocity.magnitude = 2}
        };
        returnvalue.deconstruct = function(){}
        returnvalue.render = function(cx,vpx,vpy){
          cx.beginPath();
          cx.strokeStyle=this.side.color.toHEX();
          cx.arc(this.x-vpx,this.y-vpy,5,0,2*Math.PI);
          cx.stroke();
          
          cx.beginPath();
          cx.moveTo(this.x-vpx,this.y-vpy);
          cx.lineTo(this.x-vpx + (Math.cos(this.velocity.radian())*20),this.y-vpy + (Math.sin(this.velocity.radian())*20));
          cx.closePath();
          cx.stroke();
        }
        returnvalue.hitcircle = function(){
          //var a = {type: "ship"};
          return 5;
        }
        returnvalue.health = Settings.starthealth;
        returnvalue.stars = [];
        for(var i = 0; i < 600; i++) {
          returnvalue.stars.push(new Star(c.width, c.height));
        }
        return returnvalue;
      }

*/
function generateplayer(side, x, y) {
  var returnvalue = new unit(side, x, y);
  returnvalue.health = 100;
  returnvalue.calculatelivingness = function () {
    if (this.health <= 0) {
      this.dead = true;
      unitarray.push(generateexplosion(this.x, this.y, 100));
      this.deconstruct();
    }
  }
  returnvalue.type = "player";
  returnvalue.indicatorstyle = side.color.toHEX()
  returnvalue.hit = function(type,side){
    if (type=="explosion"){this.health--}
    if (type=="bullet" && side != this.side){this.health--}
    if (type=="player" && side != this.side){this.health = 0;}
    if (type=="spawnpoint"){this.health++}
    if (type=="timebomb"){this.velocity.magnitude = 2}
  };
  returnvalue.deconstruct = function(){}
  returnvalue.tick = function () {
    this.x += Math.cos(this.velocity.radian()) * this.velocity.magnitude;
    this.y += Math.sin(this.velocity.radian()) * this.velocity.magnitude;
  }
  returnvalue.hitcircle = function () {
    return 5;
  }
  return returnvalue;
}

var sides = {};
sides.ammo = new side("Ammo", new color(255, 255, 255));
sides.evil = new side("Evil", new color(255, 0, 0));
sides.good = new side("Good", new color(255, 255, 0));
playerSides = [sides.evil, sides.good];
unitarray = new Array();

function GetRandomFromArr(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function Client() {
  this.listIndex = null;
  this.lastHeartbeat = new Date();
  this.unit = generateplayer(GetRandomFromArr(playerSides), -1, -1);
  unitarray.push(this.unit);
  unit.username = "UNSET USERNAME"
  this.disconnected = function () {}
  this.dealWith = function (e) {
    if (e.type == "moveTo") {
      //Maybe its bad to trust the client this much.
      this.unit.x = e.x;
      this.unit.y = e.y;
      this.unit.velocity = new vector(e.velocity.direction, e.velocity.magnitude);
    }
    else if (e.type == "velocityChange") {
      //Maybe its bad to trust the client this much.
      this.unit.velocity.nudge(e.direction);
      this.unit.velocity.push(e.magnitude);
    } else if (e.type == "changeUsername") {
      this.unit.username = e.username;
    } else if (e.type == "heartbeat") {
      this.lastHeartbeat = new Date();
    } else if (e.type == "spawnBullet") {
      console.log("Spawning");
      unitarray.push(generatebullet(this.unit.side, this.unit.x, this.unit.y, this.unit.velocity, 50, 5));
    }
  }
}
connections = [];
function sendToAllConnections(message){
  var i = 0;
  for (i = 0; i < connections.length; i++){
    connections[i].sendUTF(message);
  }
}
clients = [];
/* ??? clients[i].sendUTF(json); */
function onConnect(request) {
  console.log((new Date()) + ' Connection from origin ' + request.origin + '.');
  // accept connection - you should check 'request.origin' to make sure that
  // client is connecting from your website
  // (http://en.wikipedia.org/wiki/Same_origin_policy)
  console.log((new Date()) + ' Connection accepted.');
  var connection = request.accept(null, request.origin);
  var connectionindex = connections.push(connection);
  var client = new Client();
  client.connectionindex = connectionindex;
  client.listIndex = clients.push(client) - 1;
  // user sent some message
  connection.on('message', function (message) {
    if (message.type === 'utf8') { // accept only text
      var parsedData = JSON.parse(message.utf8Data);
      var i = 0;
      for (i = 0; i < parsedData.length; i++) {
        client.dealWith(parsedData[i]);
      }
    }
  });
  // user disconnected
  connection.on('close', function (connection) {
    console.log((new Date()) + " Peer " + connection.remoteAddress + " disconnected.");
    // remove user from the list of connected clients
    client.unit.health = 0;
    clients.splice(client.listIndex, 1);
    /*client.disconnected();*/
    connections.splice(client.connectionindex, 1);
  });
}

function setUp() {
  setInterval(run, 50);
}

setUp();

exports.onConnect = onConnect;
exports.setUp = setUp;
