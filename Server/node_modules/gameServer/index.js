var fs = require('fs');

// file is included here:
eval(fs.readFileSync('../both.js')+'');



function run() {
  checkcollisions();
  for (var unitindex in unitarray) {
    unitarray[unitindex].calculatelivingness();
    unitarray[unitindex].tick();
    if (unitarray[unitindex].dead) {
      Arrayremove(unitarray, unitindex);
    }
  }
}

function checkcollisions() {
  var k, j;
  for (j = 0; j < unitarray.length - 1; j++) {
    for (k = j + 1; k < unitarray.length; k++) {
      var l = (Math.pow(unitarray[j].x - unitarray[k].x, 2) + Math.pow(unitarray[j].y - unitarray[k].y, 2));
      var r = Math.pow(unitarray[k].hitcircle() + unitarray[j].hitcircle(), 2);
      if (l <= r) {
        try {
          unitarray[j].hit(unitarray[k].type, unitarray[k].side);
        } catch (e) {}
        try {
          unitarray[k].hit(unitarray[j].type, unitarray[j].side);
        } catch (e) {}
      }
    }
  }
}

function generatebullet(side, x, y, velocity, TTL, variation) {
  if (variation === undefined) {
    variation = 0;
  }
  var returnvalue = new unit(side, x, y);
  returnvalue.type = "bullet";
  returnvalue.hit = function (type, side) {};
  returnvalue.velocity = new vector(velocity.direction + (2 * (Math.random() - .5) * variation), velocity.magnitude + 2 + (Math.random() * variation));
  returnvalue.TTL = TTL;
  this.tick = function () {
    this.x += Math.cos(this.velocity.radian()) * this.velocity.magnitude;
    this.y += Math.sin(this.velocity.radian()) * this.velocity.magnitude;
    this.TTL--;
  }
  returnvalue.calculatelivingness = function () {
    if (this.TTL <= 0) {
      this.dead = true;
      unitarray.push(generateexplosion(this.x, this.y, 20));
    }
  }
  returnvalue.render = function (cx, vpx, vpy) {
    cx.beginPath();
    cx.strokeStyle = this.side.color.toHEX();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.lineTo(this.x - vpx + (Math.cos(this.velocity.radian()) * 5), this.y - vpy + (Math.sin(this.velocity.radian()) * 5));
    cx.closePath();
    cx.stroke();
  }
  returnvalue.hitcircle = function () {
    return 2;
  }
  return returnvalue;
}

function generateexplosion(x, y, size) {
  var returnvalue = new unit(sides.ammo, x, y);
  returnvalue.size = size;
  returnvalue.indicatorstyle = "#FFFFFF"
  returnvalue.width = 1;
  returnvalue.type = "explosion";
  returnvalue.hit = function (type, side) {};
  returnvalue.calculatelivingness = function () {
    if (this.width > this.size) {
      this.dead = true;
    }
  }
  this.tick = function () {
    this.width++;
  }
  returnvalue.render = function (cx, vpx, vpy) {
    cx.strokeStyle = this.side.color.toHEX();
    cx.beginPath();
    //cx.moveTo(this.x-vpx,this.y-vpy);
    cx.arc(this.x - vpx, this.y - vpy, 1 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    cx.beginPath();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.arc(this.x - vpx, this.y - vpy, .5 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    cx.beginPath();
    cx.moveTo(this.x - vpx, this.y - vpy);
    cx.arc(this.x - vpx, this.y - vpy, .25 * this.width, 0, 2 * Math.PI, false);
    cx.stroke();
    cx.closePath();
    this.width++;
  }
  returnvalue.hitcircle = function () {
    return this.width;
  }
  return returnvalue;
}

function generateammoside(sidename, sidecolor) {
  return {
    "name": sidename + "_Ammo",
    "color": new color(sidecolor.r * (20 / 51), sidecolor.g * (20 / 51), sidecolor.b * (20 / 51))
  }
}

function side(name, color) {
  this.color = color;
  this.name = name;
  this.ammoside = generateammoside(name, color);
}

function unit(side, x, y) {
  this.side = side;
  this.x = x;
  this.y = y;
  this.dead = false;
  this.velocity = new vector(0, 0);
  this.indicatorstyle = side.color.toHEX()
  this.tick = function () {};
}

function generateplayer(side, x, y) {
  var returnvalue = new unit(side, x, y);
  returnvalue.calculatelivingness = function () {
    if (this.health <= 0) {
      this.dead = true;
      unitarray.push(generateexplosion(this.x, this.y, 100));
      this.deconstruct();
    }
  }
}

var sides = [];
sides.evil = new side("Evil", new color(255, 0, 0));
sides.good = new side("Good", new color(255, 255, 0));
playerSides = [sides.evil, sides.good];
unitarray = new Array();

function GetRandomFromArr(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function Client() {
  var listIndex = null;
  unit = generateplayer(getRandom, -1, -1)
  unit.username = "UNSET USERNAME"
  generateplayer(GetRandomFromArr(playerSides), x, y);

  function disconnected() {}

  function dealWith(e) {
    if (e.type == "moveTo") {
      //Maybe its bad to trust the client this much.
      this.unit.x = e.x;
      this.unit.y = e.y;
      this.unit.velocity = e.velocity;
    } else if (e.type == "changeUsername") {
      this.unit.username = e.username;
    } else if (e.type == "spawnBullet") {
      unitarray.push(generatebullet(this.unit.side, this.unit.x, this.unit.y, this.unit.velocity, 50, 50));
    }
  }
  return this;
}
clients = [];
/* ??? clients[i].sendUTF(json); */

function onConnect(request) {
  console.log((new Date()) + ' Connection from origin ' + request.origin + '.');
  // accept connection - you should check 'request.origin' to make sure that
  // client is connecting from your website
  // (http://en.wikipedia.org/wiki/Same_origin_policy)
  console.log((new Date()) + ' Connection accepted.');
  var connection = request.accept(null, request.origin);
  var client = new Client();
  client.listIndex = clients.push(client) - 1;
  // user sent some message
  connection.on('message', function (message) {
    if (message.type === 'utf8') { // accept only text
      var parsedData = JSON.parse(message.utf8Data);
      var i = 0;
      for (i = 0; i < parsedData.length; i++) {
        client.dealWith(parsedData[i]);
      }
    }
  });
  // user disconnected
  connection.on('close', function (connection) {
    if (client.stuckAround) {
      console.log((new Date()) + " Peer " + connection.remoteAddress + " disconnected.");
      // remove user from the list of connected clients
      clients.splice(client.listIndex, 1);
      client.disconnected();
    }
  });
}

function setUp() {
  setInterval(run, 50);
}

exports.onConnect = onConnect;
exports.setUp = setUp;
